# éª¨å¹²è·¯å¾„ç³»ç»Ÿä¼˜åŒ–å»ºè®®

## ğŸ”§ éœ€è¦å®Œå–„çš„æ ¸å¿ƒé—®é¢˜

### 1. èŠ‚ç‚¹é€‰æ‹©ç­–ç•¥ä¼˜åŒ–
**å½“å‰é—®é¢˜**ï¼šåªé€‰æ‹©è·ç¦»å½“å‰ä½ç½®æœ€è¿‘çš„æ¥å£èŠ‚ç‚¹
```python
# å½“å‰å®ç° - å¯èƒ½ä¸æ˜¯å…¨å±€æœ€ä¼˜
best_interface_index = 0
min_interface_distance = float('inf')
for i in range(0, len(backbone_path), self.config['interface_spacing']):
    interface_pos = backbone_path[i]
    distance = self._calculate_distance(current_position, interface_pos)
    if distance < min_interface_distance:
        min_interface_distance = distance
        best_interface_index = i
```

**ä¼˜åŒ–å»ºè®®**ï¼šé€‰æ‹©æ€»è·¯å¾„æœ€çŸ­çš„èŠ‚ç‚¹
```python
def _find_optimal_interface_node(self, current_position, backbone_path, target_point):
    """é€‰æ‹©ä½¿æ€»è·¯å¾„æœ€çŸ­çš„æœ€ä¼˜æ¥å£èŠ‚ç‚¹"""
    best_option = None
    min_total_cost = float('inf')
    
    for i in range(0, len(backbone_path), self.config['interface_spacing']):
        interface_pos = backbone_path[i]
        
        # è®¡ç®—ï¼šå½“å‰ä½ç½®â†’æ¥å£èŠ‚ç‚¹çš„è·ç¦»
        access_distance = self._calculate_distance(current_position, interface_pos)
        
        # è®¡ç®—ï¼šæ¥å£èŠ‚ç‚¹â†’ç›®æ ‡ç‚¹çš„éª¨å¹²è·¯å¾„è·ç¦»
        remaining_backbone = backbone_path[i:]
        backbone_distance = self._calculate_path_length(remaining_backbone)
        
        # æ€»ä»£ä»·ï¼ˆå¯ä»¥åŠ å…¥æ—¶é—´ã€æ‹¥å µç­‰å› ç´ ï¼‰
        total_cost = access_distance + backbone_distance
        
        if total_cost < min_total_cost:
            min_total_cost = total_cost
            best_option = {
                'interface_index': i,
                'interface_position': interface_pos,
                'access_distance': access_distance,
                'backbone_distance': backbone_distance,
                'total_cost': total_cost
            }
    
    return best_option
```

### 2. åŠ¨æ€è´Ÿè½½å‡è¡¡
**å½“å‰é—®é¢˜**ï¼šæ²¡æœ‰è€ƒè™‘éª¨å¹²è·¯å¾„çš„æ‹¥å µæƒ…å†µ

**ä¼˜åŒ–å»ºè®®**ï¼šåœ¨èŠ‚ç‚¹é€‰æ‹©æ—¶è€ƒè™‘è·¯å¾„è´Ÿè½½
```python
def _calculate_path_load_factor(self, path_id, time_window=300):
    """è®¡ç®—è·¯å¾„åœ¨æ—¶é—´çª—å£å†…çš„è´Ÿè½½å› å­"""
    if not self.traffic_manager:
        return 0.0
    
    # ç»Ÿè®¡è¯¥è·¯å¾„ä¸Šçš„æ´»è·ƒè½¦è¾†æ•°
    active_vehicles = 0
    for vehicle_id, path_info in self.traffic_manager.active_paths.items():
        if path_info.get('backbone_path_id') == path_id:
            active_vehicles += 1
    
    # è®¡ç®—è´Ÿè½½å› å­ (0-1ï¼Œè¶Šé«˜è¶Šæ‹¥å µ)
    max_capacity = 5  # å‡è®¾æ¯æ¡éª¨å¹²è·¯å¾„æœ€å¤§å®¹é‡ä¸º5è¾†è½¦
    load_factor = min(1.0, active_vehicles / max_capacity)
    return load_factor

def _select_best_backbone_path_with_load_balancing(self, candidate_paths, current_position):
    """é€‰æ‹©è€ƒè™‘è´Ÿè½½å‡è¡¡çš„æœ€ä½³éª¨å¹²è·¯å¾„"""
    best_path = None
    best_score = float('inf')
    
    for path_data in candidate_paths:
        # åŸºç¡€è·¯å¾„è´¨é‡åˆ†æ•°
        base_score = 1.0 / path_data.quality if path_data.quality > 0 else 10.0
        
        # è´Ÿè½½æƒ©ç½šå› å­
        load_factor = self._calculate_path_load_factor(path_data.path_id)
        load_penalty = 1.0 + (load_factor * 2.0)  # è´Ÿè½½è¶Šé«˜æƒ©ç½šè¶Šå¤§
        
        # ç»¼åˆåˆ†æ•°
        total_score = base_score * load_penalty
        
        if total_score < best_score:
            best_score = total_score
            best_path = path_data
    
    return best_path
```

### 3. æ¥å£èŠ‚ç‚¹é¢„ç•™æœºåˆ¶
**å½“å‰é—®é¢˜**ï¼šæ²¡æœ‰æ¥å£èŠ‚ç‚¹å ç”¨ç®¡ç†

**ä¼˜åŒ–å»ºè®®**ï¼šå®ç°æ¥å£èŠ‚ç‚¹é¢„ç•™ç³»ç»Ÿ
```python
class InterfaceReservationManager:
    def __init__(self):
        self.reservations = {}  # {interface_id: {'vehicle_id': str, 'start_time': float, 'duration': float}}
    
    def reserve_interface(self, interface_id, vehicle_id, start_time, duration=60.0):
        """é¢„ç•™æ¥å£èŠ‚ç‚¹"""
        if self.is_interface_available(interface_id, start_time, duration):
            self.reservations[interface_id] = {
                'vehicle_id': vehicle_id,
                'start_time': start_time,
                'duration': duration
            }
            return True
        return False
    
    def is_interface_available(self, interface_id, start_time, duration):
        """æ£€æŸ¥æ¥å£èŠ‚ç‚¹æ˜¯å¦å¯ç”¨"""
        if interface_id not in self.reservations:
            return True
        
        reservation = self.reservations[interface_id]
        reserved_start = reservation['start_time']
        reserved_end = reserved_start + reservation['duration']
        
        request_end = start_time + duration
        
        # æ£€æŸ¥æ—¶é—´å†²çª
        return request_end <= reserved_start or start_time >= reserved_end
```

## ğŸš€ ç¬¬äºŒéƒ¨åˆ†ï¼šè°ƒåº¦ç³»ç»Ÿä¼˜åŒ–

### 4. ä¸»åŠ¨åœè½¦é¿è®©æœºåˆ¶
**å½“å‰é—®é¢˜**ï¼šå†²çªè§£å†³ä¸»è¦é€šè¿‡é‡æ–°è§„åˆ’ï¼Œç¼ºå°‘åœè½¦ç­‰å¾…

**ä¼˜åŒ–å»ºè®®**ï¼šå®ç°åœè½¦é¿è®©ç­–ç•¥
```python
class ConflictResolutionStrategy:
    def __init__(self):
        self.strategies = ['replan', 'wait', 'reroute', 'priority_override']
    
    def resolve_conflict_with_parking(self, conflict, vehicle_paths):
        """ä½¿ç”¨åœè½¦ç­–ç•¥è§£å†³å†²çª"""
        # é€‰æ‹©ä¼˜å…ˆçº§è¾ƒä½çš„è½¦è¾†åœè½¦ç­‰å¾…
        lower_priority_vehicle = self._select_parking_vehicle(conflict)
        
        # è®¡ç®—ç­‰å¾…æ—¶é—´
        wait_time = self._calculate_optimal_wait_time(conflict, vehicle_paths)
        
        # æ’å…¥åœè½¦æŒ‡ä»¤
        return self._insert_parking_maneuver(
            lower_priority_vehicle, 
            conflict.location, 
            wait_time
        )
    
    def _insert_parking_maneuver(self, vehicle_id, location, wait_time):
        """åœ¨è½¦è¾†è·¯å¾„ä¸­æ’å…¥åœè½¦æ“ä½œ"""
        current_path = self.active_paths[vehicle_id]['path']
        conflict_index = self._find_conflict_index(current_path, location)
        
        # åœ¨å†²çªç‚¹å‰æ’å…¥åœè½¦ä½ç½®
        parking_position = self._find_nearby_parking_spot(location)
        wait_waypoints = [parking_position] * int(wait_time / self.time_discretization)
        
        # é‡æ„è·¯å¾„ï¼šåˆ°åœè½¦ç‚¹ + ç­‰å¾… + ç»§ç»­åŸè·¯å¾„
        new_path = (current_path[:conflict_index] + 
                   wait_waypoints + 
                   current_path[conflict_index:])
        
        return new_path
```

### 5. éª¨å¹²è·¯å¾„åŠ¨æ€åˆ‡æ¢
**å½“å‰é—®é¢˜**ï¼šå†²çªæ—¶æ²¡æœ‰è€ƒè™‘åˆ‡æ¢åˆ°å…¶ä»–éª¨å¹²è·¯å¾„

**ä¼˜åŒ–å»ºè®®**ï¼šå®ç°éª¨å¹²è·¯å¾„åˆ‡æ¢æœºåˆ¶
```python
def resolve_conflict_with_backbone_switching(self, conflict, vehicle_paths):
    """é€šè¿‡åˆ‡æ¢éª¨å¹²è·¯å¾„è§£å†³å†²çª"""
    conflict_vehicle = conflict.agent1  # é€‰æ‹©ä¸€ä¸ªå†²çªè½¦è¾†
    
    # è·å–å½“å‰è½¦è¾†çš„ç›®æ ‡ä¿¡æ¯
    current_task = self._get_vehicle_current_task(conflict_vehicle)
    target_type = current_task.target_type
    target_id = current_task.target_id
    
    # æŸ¥æ‰¾æ‰€æœ‰å¯è¾¾è¯¥ç›®æ ‡çš„å¤‡é€‰éª¨å¹²è·¯å¾„
    alternative_paths = self._find_alternative_backbone_paths(
        target_type, target_id, exclude_current=True
    )
    
    if alternative_paths:
        # é€‰æ‹©æœ€ä¼˜çš„å¤‡é€‰è·¯å¾„ï¼ˆè€ƒè™‘é•¿åº¦ã€è´Ÿè½½ã€è´¨é‡ï¼‰
        best_alternative = self._select_best_alternative(
            alternative_paths, 
            conflict_vehicle,
            current_position=vehicle_paths[conflict_vehicle][conflict.time_step]
        )
        
        # é‡æ–°è§„åˆ’ä½¿ç”¨å¤‡é€‰éª¨å¹²è·¯å¾„
        new_path = self._replan_with_alternative_backbone(
            conflict_vehicle, best_alternative
        )
        
        return new_path
    
    return None  # æ— å¤‡é€‰è·¯å¾„æ—¶ä½¿ç”¨å…¶ä»–ç­–ç•¥
```

## ğŸ“Š è¿è¾“æ•ˆç‡æœ€å¤§åŒ–å»ºè®®

### 6. å…¨å±€æ•ˆç‡ä¼˜åŒ–ç›®æ ‡å‡½æ•°
```python
def calculate_system_efficiency_score(self):
    """è®¡ç®—ç³»ç»Ÿæ€»ä½“æ•ˆç‡åˆ†æ•°"""
    # 1. å®Œæˆä»»åŠ¡æ•°é‡/æ€»ä»»åŠ¡æ•°é‡
    task_completion_rate = self.stats['completed_tasks'] / max(1, self.stats['total_tasks'])
    
    # 2. éª¨å¹²è·¯å¾„åˆ©ç”¨ç‡
    backbone_utilization = self._calculate_backbone_usage_efficiency()
    
    # 3. è½¦è¾†ç©ºè½½æ—¶é—´æ¯”ä¾‹
    idle_time_ratio = self._calculate_vehicle_idle_ratio()
    
    # 4. å¹³å‡ä»»åŠ¡å®Œæˆæ—¶é—´
    avg_completion_time = self._calculate_average_task_time()
    
    # ç»¼åˆæ•ˆç‡åˆ†æ•°
    efficiency_score = (
        task_completion_rate * 0.3 +
        backbone_utilization * 0.3 +
        (1 - idle_time_ratio) * 0.2 +
        (1 / avg_completion_time) * 0.2
    )
    
    return efficiency_score
```

## ğŸ’¡ å®æ–½å»ºè®®

1. **ä¼˜å…ˆçº§é¡ºåº**ï¼š
   - èŠ‚ç‚¹é€‰æ‹©ç­–ç•¥ä¼˜åŒ– (æœ€é«˜ä¼˜å…ˆçº§)
   - åœè½¦é¿è®©æœºåˆ¶
   - åŠ¨æ€è´Ÿè½½å‡è¡¡
   - éª¨å¹²è·¯å¾„åˆ‡æ¢
   - æ•ˆç‡æœ€å¤§åŒ–ç®—æ³•

2. **æµ‹è¯•ç­–ç•¥**ï¼š
   - å•è½¦è¾†éª¨å¹²è·¯å¾„ä½¿ç”¨æµ‹è¯•
   - å¤šè½¦è¾†å†²çªåœºæ™¯æµ‹è¯•
   - é«˜è´Ÿè½½æ€§èƒ½æµ‹è¯•
   - æ•ˆç‡å¯¹æ¯”æµ‹è¯•

3. **ç›‘æ§æŒ‡æ ‡**ï¼š
   - éª¨å¹²è·¯å¾„åˆ©ç”¨ç‡
   - å†²çªè§£å†³æˆåŠŸç‡
   - å¹³å‡ä»»åŠ¡å®Œæˆæ—¶é—´
   - è½¦è¾†ç©ºè½½ç‡