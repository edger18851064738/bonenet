# é…å¥—ä»£ç ä¼˜åŒ–æŒ‡å—

## 1. ğŸš— vehicle_scheduler.py ä¼˜åŒ–

### éœ€è¦æ·»åŠ çš„æ”¯æŒ

#### A. è½¦è¾†å®‰å…¨å‚æ•°ç®¡ç†
```python
@dataclass
class EnhancedVehicleState:
    # æ·»åŠ è½¦è¾†ç‰©ç†å‚æ•°
    vehicle_length: float = 6.0
    vehicle_width: float = 3.0
    safety_margin: float = 1.5
    
    # è·¯å¾„ç¨³å®šæ€§è¿½è¸ª
    backbone_path_stability: float = 1.0
    last_backbone_switch_time: float = 0.0
    backbone_switch_count: int = 0
```

#### B. å¢å¼ºçš„è·¯å¾„æ³¨å†Œ
```python
def _start_enhanced_movement(self, task: EnhancedTask, vehicle_state: EnhancedVehicleState) -> bool:
    """å¢å¼ºçš„ç§»åŠ¨å¼€å§‹"""
    if not task.path:
        return False
    
    # æ›´æ–°çŠ¶æ€
    vehicle_state.status = VehicleStatus.MOVING
    
    # æ³¨å†Œåˆ°äº¤é€šç®¡ç†å™¨æ—¶ä¼ é€’è½¦è¾†å‚æ•°
    if self.traffic_manager:
        self.traffic_manager.register_vehicle_path(
            vehicle_state.vehicle_id, 
            task.path, 
            task.start_time,
            speed=vehicle_state.speed,
            # æ–°å¢ï¼šè½¦è¾†å®‰å…¨å‚æ•°
            vehicle_params={
                'length': vehicle_state.vehicle_length,
                'width': vehicle_state.vehicle_width,
                'safety_margin': vehicle_state.safety_margin
            }
        )
    
    # åŒæ­¥åˆ°ç¯å¢ƒæ—¶åŒ…å«æ›´å¤šä¿¡æ¯
    if vehicle_state.vehicle_id in self.env.vehicles:
        env_vehicle = self.env.vehicles[vehicle_state.vehicle_id]
        env_vehicle['status'] = 'moving'
        env_vehicle['path'] = task.path
        env_vehicle['path_structure'] = task.path_structure or {}
        # æ–°å¢ï¼šå®‰å…¨å‚æ•°
        env_vehicle['safety_params'] = {
            'length': vehicle_state.vehicle_length,
            'width': vehicle_state.vehicle_width,
            'safety_margin': vehicle_state.safety_margin
        }
```

#### C. éª¨å¹²è·¯å¾„ç¨³å®šæ€§è¿½è¸ª
```python
def _update_backbone_path_stability(self, vehicle_id: str, new_path_structure: Dict):
    """æ›´æ–°éª¨å¹²è·¯å¾„ç¨³å®šæ€§"""
    vehicle_state = self.vehicle_states.get(vehicle_id)
    if not vehicle_state:
        return
    
    current_backbone_id = new_path_structure.get('path_id')
    if current_backbone_id:
        # æ£€æŸ¥æ˜¯å¦åˆ‡æ¢äº†éª¨å¹²è·¯å¾„
        last_backbone_id = getattr(vehicle_state, 'last_backbone_path_id', None)
        
        if last_backbone_id and last_backbone_id != current_backbone_id:
            # è®°å½•åˆ‡æ¢
            vehicle_state.backbone_switch_count += 1
            vehicle_state.last_backbone_switch_time = time.time()
            vehicle_state.backbone_path_stability = max(0.1, 
                vehicle_state.backbone_path_stability - 0.2)
            
            print(f"è½¦è¾† {vehicle_id} åˆ‡æ¢éª¨å¹²è·¯å¾„: {last_backbone_id} -> {current_backbone_id}")
        else:
            # ä¿æŒç¨³å®šï¼Œæå‡ç¨³å®šæ€§åˆ†æ•°
            vehicle_state.backbone_path_stability = min(1.0,
                vehicle_state.backbone_path_stability + 0.05)
        
        vehicle_state.last_backbone_path_id = current_backbone_id
```

## 2. ğŸ›£ï¸ optimized_backbone_network.py ä¼˜åŒ–

### éœ€è¦å¢å¼ºçš„æ–¹æ³•

#### A. æ”¹è¿›å¤‡é€‰è·¯å¾„æŸ¥æ‰¾
```python
def find_alternative_backbone_paths(self, target_type: str, target_id: int, 
                                  exclude_path_id: str = None,
                                  min_quality: float = 0.5,
                                  max_load_factor: float = 0.7) -> List:
    """æŸ¥æ‰¾é«˜è´¨é‡ã€ä½è´Ÿè½½çš„å¤‡é€‰éª¨å¹²è·¯å¾„"""
    alternatives = []
    
    for path_id, path_data in self.bidirectional_paths.items():
        if path_id == exclude_path_id:
            continue
            
        # æ£€æŸ¥æ˜¯å¦è¿æ¥åˆ°ç›®æ ‡
        if ((path_data.point_a['type'] == target_type and path_data.point_a['id'] == target_id) or
            (path_data.point_b['type'] == target_type and path_data.point_b['id'] == target_id)):
            
            # è´¨é‡å’Œè´Ÿè½½è¿‡æ»¤
            if (path_data.quality >= min_quality and 
                path_data.get_load_factor() <= max_load_factor):
                alternatives.append(path_data)
    
    # æŒ‰è´¨é‡å’Œè´Ÿè½½æ’åº - è´¨é‡é«˜ã€è´Ÿè½½ä½çš„ä¼˜å…ˆ
    alternatives.sort(key=lambda p: (-p.quality, p.get_load_factor()))
    
    return alternatives
```

#### B. è·¯å¾„åˆ‡æ¢æ§åˆ¶
```python
def request_backbone_path_switch(self, vehicle_id: str, current_position: Tuple,
                                target_type: str, target_id: int,
                                switch_reason: str = "conflict_resolution") -> Optional[Tuple]:
    """è¯·æ±‚éª¨å¹²è·¯å¾„åˆ‡æ¢ - å¸¦ç¨³å®šæ€§æ£€æŸ¥"""
    
    # æ£€æŸ¥è½¦è¾†åˆ‡æ¢å†å²
    if vehicle_id in self.vehicle_path_assignments:
        current_path_id = self.vehicle_path_assignments[vehicle_id]
        current_path = self.bidirectional_paths.get(current_path_id)
        
        if current_path:
            # æ£€æŸ¥å½“å‰è·¯å¾„è´Ÿè½½æ˜¯å¦çœŸçš„éœ€è¦åˆ‡æ¢
            current_load = current_path.get_load_factor()
            if current_load < 0.6 and switch_reason == "load_balancing":
                print(f"è½¦è¾† {vehicle_id} å½“å‰è·¯å¾„è´Ÿè½½é€‚ä¸­ï¼Œè·³è¿‡åˆ‡æ¢")
                return None
    
    # æŸ¥æ‰¾æ›´ä¼˜çš„å¤‡é€‰è·¯å¾„
    alternatives = self.find_alternative_backbone_paths(
        target_type, target_id, 
        exclude_path_id=self.vehicle_path_assignments.get(vehicle_id),
        min_quality=0.6,
        max_load_factor=0.5
    )
    
    if alternatives:
        best_alternative = alternatives[0]
        
        # ä½¿ç”¨å¤‡é€‰è·¯å¾„é‡æ–°è§„åˆ’
        result = self.get_path_from_position_to_target(
            current_position, target_type, target_id, vehicle_id,
            preferred_backbone_id=best_alternative.path_id
        )
        
        if result:
            print(f"ä¸ºè½¦è¾† {vehicle_id} æˆåŠŸåˆ‡æ¢åˆ°å¤‡é€‰éª¨å¹²è·¯å¾„: {best_alternative.path_id}")
            return result
    
    return None
```

#### C. æ™ºèƒ½æ¥å£èŠ‚ç‚¹é€‰æ‹©
```python
def _find_optimal_interface_node_enhanced(self, current_position: Tuple, 
                                        path_data: Any, target_type: str, target_id: int,
                                        vehicle_params: Dict = None) -> Optional[Dict]:
    """å¢å¼ºçš„æœ€ä¼˜æ¥å£èŠ‚ç‚¹é€‰æ‹© - è€ƒè™‘è½¦è¾†å®‰å…¨å‚æ•°"""
    
    # è·å–è½¦è¾†å®‰å…¨å‚æ•°
    safety_margin = vehicle_params.get('safety_margin', 1.5) if vehicle_params else 1.5
    
    # ç¡®å®šä½¿ç”¨æ–¹å‘å’Œè·¯å¾„
    if path_data.point_a['type'] == target_type and path_data.point_a['id'] == target_id:
        backbone_path = path_data.reverse_path
        target_point = path_data.point_a['position']
    else:
        backbone_path = path_data.forward_path
        target_point = path_data.point_b['position']
    
    best_option = None
    min_total_cost = float('inf')
    
    # åŠ¨æ€è°ƒæ•´æ¥å£é—´è· - è€ƒè™‘å®‰å…¨è·ç¦»
    safe_spacing = max(self.config['interface_spacing'], int(safety_margin * 3))
    
    for i in range(0, len(backbone_path), safe_spacing):
        interface_pos = backbone_path[i]
        
        # è®¡ç®—åˆ°æ¥å£çš„è·ç¦»
        access_distance = self._calculate_distance(current_position, interface_pos)
        
        # å®‰å…¨æ€§æ£€æŸ¥ - ç¡®ä¿æ¥å£ä½ç½®å®‰å…¨
        if not self._is_interface_position_safe(interface_pos, vehicle_params):
            continue
        
        # è®¡ç®—æ€»ä»£ä»·
        remaining_backbone = backbone_path[i:]
        backbone_distance = self._calculate_path_length(remaining_backbone)
        
        # æ¥å£æ‹¥å µå› å­
        interface_id = f"{path_data.path_id}_if_{i // safe_spacing}"
        congestion_factor = self._get_interface_congestion_factor(interface_id)
        
        total_cost = (access_distance + backbone_distance) * congestion_factor
        
        if total_cost < min_total_cost:
            min_total_cost = total_cost
            best_option = {
                'interface_index': i,
                'interface_position': interface_pos,
                'access_distance': access_distance,
                'backbone_distance': backbone_distance,
                'total_cost': total_cost,
                'remaining_path': remaining_backbone,
                'safety_score': self._calculate_position_safety_score(interface_pos, vehicle_params)
            }
    
    return best_option

def _is_interface_position_safe(self, position: Tuple, vehicle_params: Dict = None) -> bool:
    """æ£€æŸ¥æ¥å£ä½ç½®æ˜¯å¦å¯¹è½¦è¾†å®‰å…¨"""
    if not vehicle_params:
        return True
    
    x, y = position[0], position[1]
    length = vehicle_params.get('length', 6.0)
    width = vehicle_params.get('width', 3.0)
    margin = vehicle_params.get('safety_margin', 1.5)
    
    # æ£€æŸ¥å‘¨å›´åŒºåŸŸæ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
    check_radius = max(length, width) / 2 + margin
    
    # ç®€åŒ–çš„å®‰å…¨æ£€æŸ¥
    for dx in range(-int(check_radius), int(check_radius) + 1):
        for dy in range(-int(check_radius), int(check_radius) + 1):
            check_x, check_y = int(x + dx), int(y + dy)
            
            if (0 <= check_x < self.env.width and 
                0 <= check_y < self.env.height and
                hasattr(self.env, 'grid') and
                self.env.grid[check_x, check_y] == 1):
                return False
    
    return True
```

## 3. ğŸ—ºï¸ path_planner.py ä¼˜åŒ–

### éœ€è¦å¢å¼ºçš„è§„åˆ’æ¥å£

#### A. æ”¯æŒå†²çªè§£å†³ä¸Šä¸‹æ–‡
```python
def plan_path(self, vehicle_id: str, start: Tuple, goal: Tuple,
              use_backbone: bool = True, check_conflicts: bool = True,
              planner_type: str = "auto", context: str = "normal",
              return_object: bool = False, 
              # æ–°å¢å‚æ•°
              vehicle_params: Dict = None,
              conflict_avoidance: bool = False,
              min_safety_clearance: float = None,
              **kwargs) -> Optional[Union[List, Tuple[List, Dict], Any]]:
    """
    å¢å¼ºçš„è·¯å¾„è§„åˆ’æ¥å£
    
    æ–°å¢å‚æ•°:
        vehicle_params: è½¦è¾†å®‰å…¨å‚æ•°
        conflict_avoidance: æ˜¯å¦è¿›è¡Œå†²çªé¿è®©è§„åˆ’
        min_safety_clearance: æœ€å°å®‰å…¨é—´éš”
    """
    
    # æ ¹æ®ä¸Šä¸‹æ–‡è°ƒæ•´è§„åˆ’å‚æ•°
    if context == "conflict_resolution":
        # å†²çªè§£å†³æ—¶è¦æ±‚æ›´é«˜è´¨é‡
        kwargs['quality_threshold'] = kwargs.get('quality_threshold', 0.7)
        if conflict_avoidance:
            kwargs['safety_bias'] = 1.5  # å¢åŠ å®‰å…¨æ€§åç½®
    
    # è®¾ç½®è½¦è¾†å®‰å…¨å‚æ•°
    if vehicle_params:
        if 'safety_margin' in vehicle_params:
            min_safety_clearance = vehicle_params['safety_margin']
    
    # è°ƒç”¨åŸæœ‰è§„åˆ’é€»è¾‘
    result = self._plan_with_strategy(
        vehicle_id, start, goal, planner_type, context, 
        use_backbone, time.time(), 
        vehicle_params=vehicle_params,
        min_safety_clearance=min_safety_clearance,
        **kwargs
    )
    
    # å¢å¼ºç»“æœä¿¡æ¯
    if result and isinstance(result, tuple):
        path, structure = result
        
        # æ·»åŠ å®‰å…¨æ€§è¯„ä¼°
        structure['safety_score'] = self._evaluate_path_safety(
            path, vehicle_params, min_safety_clearance
        )
        
        # æ·»åŠ å†²çªé£é™©è¯„ä¼°
        if self.traffic_manager:
            structure['conflict_risk'] = self._estimate_conflict_risk(path, vehicle_id)
        
        result = (path, structure)
    
    return result

def _evaluate_path_safety(self, path: List, vehicle_params: Dict = None, 
                         min_clearance: float = None) -> float:
    """è¯„ä¼°è·¯å¾„å®‰å…¨æ€§"""
    if not path or len(path) < 2:
        return 0.5
    
    safety_score = 1.0
    clearance = min_clearance or 2.0
    
    # æ£€æŸ¥è·¯å¾„ç‚¹çš„å®‰å…¨é—´éš”
    for point in path:
        x, y = point[0], point[1]
        
        # æ£€æŸ¥åˆ°éšœç¢ç‰©çš„è·ç¦»
        min_obstacle_distance = self._get_min_obstacle_distance(x, y)
        
        if min_obstacle_distance < clearance:
            # è·ç¦»éšœç¢ç‰©å¤ªè¿‘ï¼Œé™ä½å®‰å…¨åˆ†æ•°
            safety_penalty = (clearance - min_obstacle_distance) / clearance
            safety_score -= safety_penalty * 0.1
    
    return max(0.1, min(1.0, safety_score))

def _estimate_conflict_risk(self, path: List, vehicle_id: str) -> float:
    """ä¼°ç®—è·¯å¾„å†²çªé£é™©"""
    if not self.traffic_manager or not path:
        return 0.0
    
    # ç®€åŒ–çš„å†²çªé£é™©è¯„ä¼°
    risk_score = 0.0
    
    # æ£€æŸ¥è·¯å¾„æ˜¯å¦ç»è¿‡é«˜æµé‡åŒºåŸŸ
    for point in path[::5]:  # é‡‡æ ·æ£€æŸ¥
        # æ£€æŸ¥è¯¥ä½ç½®é™„è¿‘çš„è½¦è¾†å¯†åº¦
        nearby_vehicles = self._count_nearby_vehicles(point, radius=10.0)
        
        if nearby_vehicles > 2:
            risk_score += 0.1
    
    return min(1.0, risk_score)
```

## 4. ğŸŒ environment.py ä¼˜åŒ–

### è½¦è¾†ä¿¡æ¯å¢å¼º

#### A. æ‰©å±•è½¦è¾†ä¿¡æ¯ç»“æ„
```python
@dataclass
class VehicleInfo:
    """å¢å¼ºçš„è½¦è¾†ä¿¡æ¯"""
    vehicle_id: str
    position: Tuple[float, float, float]
    initial_position: Tuple[float, float, float]
    goal: Optional[Tuple[float, float, float]] = None
    
    # åŸºæœ¬å±æ€§
    vehicle_type: str = "dump_truck"
    max_load: float = 100
    current_load: float = 0
    speed: float = 1.0
    
    # æ–°å¢ï¼šå®‰å…¨å‚æ•°
    vehicle_length: float = 6.0
    vehicle_width: float = 3.0
    safety_margin: float = 1.5
    turning_radius: float = 8.0
    
    # çŠ¶æ€ä¿¡æ¯
    status: str = 'idle'
    path: Optional[List] = None
    path_index: int = 0
    progress: float = 0.0
    
    # æ–°å¢ï¼šå®‰å…¨å’Œå†²çªç›¸å…³
    safety_params: Dict = None
    last_conflict_time: float = 0.0
    conflict_count: int = 0
    
    def __post_init__(self):
        if self.color is None:
            self.color = QColor(random.randint(100, 255), random.randint(100, 255), random.randint(100, 255))
        
        if self.path_structure is None:
            self.path_structure = {}
            
        # åˆå§‹åŒ–å®‰å…¨å‚æ•°
        if self.safety_params is None:
            self.safety_params = {
                'length': self.vehicle_length,
                'width': self.vehicle_width,
                'safety_margin': self.safety_margin,
                'turning_radius': self.turning_radius
            }
```

#### B. å®‰å…¨æ£€æŸ¥å¢å¼º
```python
def check_collision_enhanced(self, position: Tuple[float, float, float], 
                           vehicle_params: Dict = None,
                           exclude_vehicle: str = None) -> bool:
    """å¢å¼ºçš„ç¢°æ’æ£€æµ‹ - è€ƒè™‘è½¦è¾†çœŸå®å°ºå¯¸"""
    try:
        x, y, theta = float(position[0]), float(position[1]), float(position[2])
        
        # è·å–è½¦è¾†å‚æ•°
        if vehicle_params:
            length = vehicle_params.get('length', 6.0)
            width = vehicle_params.get('width', 3.0)
            safety_margin = vehicle_params.get('safety_margin', 1.5)
        else:
            length, width, safety_margin = 6.0, 3.0, 1.5
        
        # è®¡ç®—è½¦è¾†å ç”¨çš„çŸ©å½¢åŒºåŸŸ
        half_length = (length + safety_margin) / 2
        half_width = (width + safety_margin) / 2
        
        # è½¦è¾†å››ä¸ªè§’ç‚¹ï¼ˆè€ƒè™‘æ—‹è½¬ï¼‰
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)
        
        corners = [
            (x + half_length * cos_theta - half_width * sin_theta,
             y + half_length * sin_theta + half_width * cos_theta),
            (x + half_length * cos_theta + half_width * sin_theta,
             y + half_length * sin_theta - half_width * cos_theta),
            (x - half_length * cos_theta + half_width * sin_theta,
             y - half_length * sin_theta - half_width * cos_theta),
            (x - half_length * cos_theta - half_width * sin_theta,
             y - half_length * sin_theta + half_width * cos_theta)
        ]
        
        # æ£€æŸ¥è¾¹ç•Œ
        for corner_x, corner_y in corners:
            if (corner_x < 0 or corner_x >= self.width or 
                corner_y < 0 or corner_y >= self.height):
                return True
        
        # æ£€æŸ¥éšœç¢ç‰©ç¢°æ’
        for corner_x, corner_y in corners:
            ix, iy = int(corner_x), int(corner_y)
            if (0 <= ix < self.width and 0 <= iy < self.height and
                hasattr(self, 'grid') and self.grid[ix, iy] == 1):
                return True
        
        # æ£€æŸ¥ä¸å…¶ä»–è½¦è¾†çš„ç¢°æ’
        enhanced_safety_radius = max(length, width) + safety_margin
        for vehicle_id, vehicle_info in self.vehicles.items():
            if vehicle_id == exclude_vehicle:
                continue
            
            other_pos = vehicle_info.position
            distance = math.sqrt(
                (x - other_pos[0])**2 + (y - other_pos[1])**2
            )
            
            # è€ƒè™‘ä¸¤è½¦çš„å®‰å…¨è·ç¦»
            other_params = vehicle_info.safety_params or {}
            other_safety_radius = max(
                other_params.get('length', 6.0), 
                other_params.get('width', 3.0)
            ) + other_params.get('safety_margin', 1.5)
            
            required_distance = (enhanced_safety_radius + other_safety_radius) / 2
            
            if distance < required_distance:
                return True
        
        return False
        
    except Exception:
        return True
```

## 5. ğŸ“Š 111.py (GUI) ä¼˜åŒ–

### å¯è§†åŒ–å¢å¼º

#### A. å®‰å…¨çŸ©å½¢æ˜¾ç¤º
```python
class VehicleGraphicsItem(QGraphicsItemGroup):
    """ä¸“ä¸šçš„è½¦è¾†å›¾å½¢é¡¹ - æ”¯æŒå®‰å…¨çŸ©å½¢æ˜¾ç¤º"""
    
    def __init__(self, vehicle_id, vehicle_data, parent=None):
        super().__init__(parent)
        self.vehicle_id = vehicle_id
        self.vehicle_data = vehicle_data
        self.position = vehicle_data.get('position', (0, 0, 0))
        
        # åˆ›å»ºè½¦è¾†ç»„ä»¶
        self.vehicle_body = QGraphicsPolygonItem(self)
        self.safety_rectangle = QGraphicsRectItem(self)  # æ–°å¢ï¼šå®‰å…¨çŸ©å½¢
        self.status_indicator = QGraphicsEllipseItem(self)
        self.load_indicator = QGraphicsRectItem(self)
        self.direction_line = QGraphicsLineItem(self)
        self.efficiency_ring = QGraphicsEllipseItem(self)
        
        # æ–°å¢ï¼šå†²çªè­¦å‘ŠæŒ‡ç¤ºå™¨
        self.conflict_warning = QGraphicsEllipseItem(self)
        self.conflict_warning.setVisible(False)
        
        self.setZValue(15)
        self.update_appearance()
        self.update_position()
    
    def update_appearance(self):
        """æ›´æ–°è½¦è¾†å¤–è§‚ - åŒ…å«å®‰å…¨çŸ©å½¢"""
        status = self.vehicle_data.get('status', 'idle')
        color = VEHICLE_STATUS_COLORS.get(status, VEHICLE_STATUS_COLORS['idle'])
        
        # è½¦è¾†ä¸»ä½“
        self.vehicle_body.setBrush(QBrush(color))
        self.vehicle_body.setPen(QPen(color.darker(150), 1))
        
        # å®‰å…¨çŸ©å½¢ - åŠé€æ˜æ˜¾ç¤º
        safety_params = self.vehicle_data.get('safety_params', {})
        if safety_params:
            safety_color = QColor(color.red(), color.green(), color.blue(), 50)
            self.safety_rectangle.setBrush(QBrush(safety_color))
            self.safety_rectangle.setPen(QPen(color.lighter(120), 1, Qt.DashLine))
        
        # å†²çªè­¦å‘Š
        conflict_count = self.vehicle_data.get('conflict_count', 0)
        if conflict_count > 0:
            self.conflict_warning.setVisible(True)
            warning_color = QColor(255, 0, 0, 150)
            self.conflict_warning.setBrush(QBrush(warning_color))
            self.conflict_warning.setPen(QPen(Qt.red, 2))
        else:
            self.conflict_warning.setVisible(False)
    
    def update_position(self):
        """æ›´æ–°è½¦è¾†ä½ç½® - åŒ…å«å®‰å…¨çŸ©å½¢"""
        if not self.position or len(self.position) < 3:
            return
        
        x, y, theta = self.position
        
        # è½¦è¾†ä¸»ä½“å°ºå¯¸
        safety_params = self.vehicle_data.get('safety_params', {})
        length = safety_params.get('length', 6.0)
        width = safety_params.get('width', 3.0)
        safety_margin = safety_params.get('safety_margin', 1.5)
        
        # æ›´æ–°å®‰å…¨çŸ©å½¢
        safe_length = length + safety_margin
        safe_width = width + safety_margin
        
        self.safety_rectangle.setRect(
            x - safe_length/2, y - safe_width/2, 
            safe_length, safe_width
        )
        
        # åº”ç”¨æ—‹è½¬
        transform = QTransform()
        transform.translate(x, y)
        transform.rotate(math.degrees(theta))
        self.safety_rectangle.setTransform(transform)
        
        # æ›´æ–°å†²çªè­¦å‘Šä½ç½®
        self.conflict_warning.setRect(x - 2, y - 2, 4, 4)
        
        # ... å…¶ä»–åŸæœ‰çš„ä½ç½®æ›´æ–°é€»è¾‘
```

#### B. æ–°å¢ç»Ÿè®¡é¢æ¿
```python
class ConflictMonitoringWidget(QWidget):
    """å†²çªç›‘æ§ç»„ä»¶"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.traffic_manager = None
        self.init_ui()
    
    def init_ui(self):
        """åˆå§‹åŒ–ç•Œé¢"""
        layout = QVBoxLayout(self)
        
        # æ ‡é¢˜
        title = QLabel("å†²çªç›‘æ§")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: rgb(229, 231, 235);
                padding: 8px;
                background-color: rgb(239, 68, 68);
                border-radius: 4px;
            }
        """)
        layout.addWidget(title)
        
        # å†²çªç»Ÿè®¡
        conflict_group = QGroupBox("å†²çªæ£€æµ‹")
        conflict_layout = QVBoxLayout()
        
        self.total_conflicts_label = QLabel("æ€»å†²çªæ•°: 0")
        self.rectangle_conflicts_label = QLabel("çŸ©å½¢å†²çª: 0")
        self.resolved_conflicts_label = QLabel("å·²è§£å†³: 0")
        self.resolution_rate_label = QLabel("è§£å†³ç‡: 0%")
        
        conflict_layout.addWidget(self.total_conflicts_label)
        conflict_layout.addWidget(self.rectangle_conflicts_label)
        conflict_layout.addWidget(self.resolved_conflicts_label)
        conflict_layout.addWidget(self.resolution_rate_label)
        
        conflict_group.setLayout(conflict_layout)
        layout.addWidget(conflict_group)
        
        # ç­–ç•¥åˆ†å¸ƒ
        strategy_group = QGroupBox("ç­–ç•¥ä½¿ç”¨åˆ†å¸ƒ")
        strategy_layout = QVBoxLayout()
        
        self.replan_count_label = QLabel("é‡è§„åˆ’: 0")
        self.backbone_switch_label = QLabel("éª¨å¹²åˆ‡æ¢: 0")
        self.wait_count_label = QLabel("åœè½¦ç­‰å¾…: 0")
        
        strategy_layout.addWidget(self.replan_count_label)
        strategy_layout.addWidget(self.backbone_switch_label)
        strategy_layout.addWidget(self.wait_count_label)
        
        strategy_group.setLayout(strategy_layout)
        layout.addWidget(strategy_group)
        
        # éª¨å¹²ç¨³å®šæ€§
        stability_group = QGroupBox("è·¯å¾„ç¨³å®šæ€§")
        stability_layout = QVBoxLayout()
        
        self.stability_score_bar = self._create_progress_bar("ç¨³å®šæ€§åˆ†æ•°")
        stability_layout.addWidget(self.stability_score_bar[0])
        stability_layout.addWidget(self.stability_score_bar[1])
        
        self.switches_avoided_label = QLabel("é¿å…åˆ‡æ¢: 0")
        stability_layout.addWidget(self.switches_avoided_label)
        
        stability_group.setLayout(stability_layout)
        layout.addWidget(stability_group)
    
    def update_conflict_stats(self):
        """æ›´æ–°å†²çªç»Ÿè®¡"""
        if not self.traffic_manager:
            return
        
        stats = self.traffic_manager.get_statistics()
        
        # å†²çªç»Ÿè®¡
        total_conflicts = stats.get('total_conflicts', 0)
        rectangle_conflicts = stats.get('rectangle_conflicts_detected', 0)
        resolved_conflicts = stats.get('resolved_conflicts', 0)
        
        self.total_conflicts_label.setText(f"æ€»å†²çªæ•°: {total_conflicts}")
        self.rectangle_conflicts_label.setText(f"çŸ©å½¢å†²çª: {rectangle_conflicts}")
        self.resolved_conflicts_label.setText(f"å·²è§£å†³: {resolved_conflicts}")
        
        # è§£å†³ç‡
        if total_conflicts > 0:
            resolution_rate = (resolved_conflicts / total_conflicts) * 100
            self.resolution_rate_label.setText(f"è§£å†³ç‡: {resolution_rate:.1f}%")
        
        # ç­–ç•¥åˆ†å¸ƒ
        strategy_dist = stats.get('strategy_distribution', {})
        self.replan_count_label.setText(f"é‡è§„åˆ’: {strategy_dist.get('replan', 0)}")
        self.backbone_switch_label.setText(f"éª¨å¹²åˆ‡æ¢: {strategy_dist.get('backbone_switch', 0)}")
        self.wait_count_label.setText(f"åœè½¦ç­‰å¾…: {strategy_dist.get('wait', 0)}")
        
        # ç¨³å®šæ€§åˆ†æ•°
        stability_score = stats.get('backbone_stability_score', 1.0)
        self.stability_score_bar[1].setValue(int(stability_score * 100))
        
        # é¿å…çš„åˆ‡æ¢æ¬¡æ•°
        resolution_stats = stats.get('resolution_strategies', {})
        switches_avoided = resolution_stats.get('backbone_switches_avoided', 0)
        self.switches_avoided_label.setText(f"é¿å…åˆ‡æ¢: {switches_avoided}")
```

## ğŸ”§ ä¸»è¦ä¿®æ”¹æ€»ç»“

### 1. **è½¦è¾†è°ƒåº¦å™¨**
- æ·»åŠ è½¦è¾†å®‰å…¨å‚æ•°ç®¡ç†
- å®ç°éª¨å¹²è·¯å¾„ç¨³å®šæ€§è¿½è¸ª
- å¢å¼ºè·¯å¾„æ³¨å†Œæ—¶çš„ä¿¡æ¯ä¼ é€’

### 2. **éª¨å¹²ç½‘ç»œ**
- æ”¹è¿›å¤‡é€‰è·¯å¾„æŸ¥æ‰¾ç®—æ³•
- æ·»åŠ è·¯å¾„åˆ‡æ¢æ§åˆ¶æœºåˆ¶
- æ™ºèƒ½æ¥å£èŠ‚ç‚¹é€‰æ‹©

### 3. **è·¯å¾„è§„åˆ’å™¨**
- æ”¯æŒå†²çªè§£å†³ä¸Šä¸‹æ–‡
- å¢åŠ å®‰å…¨æ€§å’Œå†²çªé£é™©è¯„ä¼°
- è¿”å›æ›´ä¸°å¯Œçš„è·¯å¾„ç»“æ„ä¿¡æ¯

### 4. **ç¯å¢ƒç®¡ç†**
- æ‰©å±•è½¦è¾†ä¿¡æ¯ç»“æ„
- å¢å¼ºç¢°æ’æ£€æµ‹ç®—æ³•
- æ·»åŠ å®‰å…¨å‚æ•°æ”¯æŒ

### 5. **GUIç•Œé¢**
- å¯è§†åŒ–å®‰å…¨çŸ©å½¢
- æ–°å¢å†²çªç›‘æ§é¢æ¿
- æ˜¾ç¤ºè·¯å¾„ç¨³å®šæ€§æŒ‡æ ‡

è¿™äº›ä¿®æ”¹ç¡®ä¿äº†æ•´ä¸ªç³»ç»Ÿèƒ½å¤Ÿå……åˆ†åˆ©ç”¨æ–°çš„å®‰å…¨çŸ©å½¢å†²çªæ£€æµ‹å’Œä¼˜åŒ–ç­–ç•¥ï¼ŒåŒæ—¶ä¿æŒäº†æ¥å£çš„å…¼å®¹æ€§ã€‚